#操作系统实验一
PB16050193胡煜霄
##实验目的
    使用调试跟踪工具，追踪自己操作系统（本次实验中使用linux）的启动过程，了解操作系统启动的基本流程，加深对操作系统的理解。
##环境搭建
    本次实验中使用linux系统，通过在ubuntu17.10系统中搭建一个menuOS并使用gdb调试的方法模拟追踪操作系统的启动。
    首先是下载相应的内核压缩包：在kernel.org中下载3.18.102版本内核并解压缩。
    解压缩后使用make命令进行编译，这时发现系统报错，于是使用make menuconfig命令来进行编译的配置，选择64-bit kernel并且选择compile the kernel with debug info,随后保存退出。使用make命令重新编译(这部分花了较长时间)
    *注：以上编译过程进行时需在root用户状态下进行*
    之后从https://github.com/mengning/menu.git进行git clone来制作根文件系统。
    随后即可使用gdb跟踪调试内核，在包含内核目录的目录中执行以下语句：
    `qemu-system-x86_64 -kernel linux-3.18.102/arch/x86/boot/bzImage -initrd rootfs.img -s -S `
    来启动qemu，由于添加了*-S*参数，cpu此时被冻结；而*-s*参数是默认使用1234端口使gdb和qemu进行连接。*这里需要注意的是，在使用qemu时一定要退出root用户模式，否则会报错*
    另外启动一个终端，进入包含内核目录的目录，输入gdb命令进入gdb调试，随后输入以下命令加载符号并建立gdb和gdbserver的连接：
```
    （gdb）file linux-3.18.102/vmlinux
    （gdb）target remote:1234 
```
    这样，环境的搭建就已经完成，可以开始进行内核的调试了。
##进行调试
    首先，使用i r指令调出最原始状态下的寄存器：
```
    rax            0x0	0
    rbx            0x0	0
    rcx            0x0	0
    rdx            0x663	1635
    rsi            0x0	0
    rdi            0x0	0
    rbp            0x0	0x0 <irq_stack_union>
    rsp            0x0	0x0 <irq_stack_union>
    r8             0x0	0
    r9             0x0	0
    r10            0x0	0
    r11            0x0	0
    r12            0x0	0
    r13            0x0	0
    r14            0x0	0
    r15            0x0	0
    rip            0xfff0	0xfff0 <ladder_devices+80>
    eflags         0x2	[ ]
    cs             0xf000	61440
    ss             0x0	0
    ds             0x0	0
    es             0x0	0
    fs             0x0	0
    gs             0x0	0
```
    主要看rip和cs寄存器，eip的内容为0xfff0,表示计算机加电后ip首先指向0xfff0，这里实际上保存着一个跳转指令，跳转向bios代码处。cs表示此时函数所处代码段，此时调出函数堆栈状态可见：
    `#0  0x000000000000fff0 in ladder_devices ()`
    `#1  0x0000000000000000 in ?? ()`
    此时在函数ladder_device中，由于对汇编代码不熟悉所以不再追踪汇编代码执行阶段的代码，只知道在这个阶段中进行了物理和虚拟内存的设置和叶表的建立和设置各种参数。
    随后便进入了我们所熟知的c语言代码段，即进入start_kernel函数
    在这里我使用了gdb中的`layout src`指令将内核代码和我正在命令行进行分屏，这样方便我们随时查看代码而不需要重复的使用list指令来寻找代码，同时，此功能还能帮助我们方便的定位到代码执行到的位置。
    start_kernel中调用的前4个函数分别为：
    lockdep_init();                             
    set_task_stack_end_magic(&init_task);       
    smp_setup_processor_id();                   
    debug_objects_early_init();
    lockdep_initl主要是检查内核互锁机制,所以应该尽早运行，
    其余函数是进行一些早期的初始化，包括初始化hash表，获取当前cpu等操作

    然后是在本次实验中认为比较重要的一个操作： boot_init_stack_canary()，这个函数设置一个栈canary值，用于防止栈溢出攻击

    然后调用了cgroup 的早期初始化函数，对其进行初始化。在这之后是一个比较关键的事件：
    调用了local_irq_disable()函数关闭了系统的中断，以方便后续一些初始化操作的进行。
    后续即是调用了一系列对cpu和内核相关的初始化函数。
    其中有一个非常重要的函数是：setup_arch(&command_line)
    由于这个函数非常庞大，所以我只分析了其中一部分我认为比较关键的内容：每个体系结构 都会有一个自己的setup_arch函数，所以它是体系结构相关的，它首先通过编译过程中检测出来的处理器类型进行处理器内核的初始化，然后对meminfo内存结构进行过初始化，最后开启MMU，创建内核叶表，映射物理内存和io空间。可以看出，此函数的调用是将处理器硬件进行抽象的关键的一步
    随后又进行一些初始化函数调用后，调用local_irq_enable()使中断恢复可用。
    回复中断后所进行的一个重要操作就是console_init，初始化控制台，因为此时还是操作系统启动的很初始的阶段，所以之进行一些简单的初始化，而将一些复杂步骤都推到后面再进行。提前进行控制台的初始化的目的在于及时的打印出内核启动过程中产生的一些信息，不难看出，前面已经多次产生了printk信息，这些信息由于控制台没有初始化而没有打印出来，一直存放在缓冲区中，及时将这些信息打印出来才能更好的调试解决启动中产生的问题。随后进行了死锁检测。
    之后调用late_time_init函数，它能注册并将hpet作为时钟源并打印出校准信息。
    这里有一个有趣的cpu新能测试函数calibrate_delay。它能计算出cpu在1s内执行了多少次一个极短的循环，本次模拟中得到：4799.98bogomips   ipj=9599960
    走到pidmap_init函数，这里可以设置pid的大小，决定了在后续运行中pid的最大值
    然后就又到了一个关键的地方：acpi_early_init，这里对acpi进行了一系列初始化操作。acpi建立了系统和bios到硬件之间的新型接口，在这个函数执行完毕后，我们就能获得acpi的表。
    在这之后仍旧是一系列的初始化操作，值得一提的是，在这部分调用了acpi_subsystem_init函数，转换为acpi模式，进行acpi事件解决的初始化操作，安装了中断和全局锁的解决。这个操作执行的这么早虽然会有一定的风险但是它必须在所有依赖acpi的进程执行之前就执行完毕。
    最后就是rest_init 函数的调用进行剩余的初始化，并创建启动了pid为1的init进程，如果按步执行代码就会发现，init最终会反复执行cpu_idle中的一个循环以占用其空闲时间片，当有其他进程j需要工作时这个函数才会被抢占。
##总结
    在本次实验中，初次进行了linux操作系统的安装和使用，并且对其内核的启动过程进行了追踪调试，了解了其启动的一般过程，找到了数个认为关键的事件进行分析，对linux操作系统的运作有了一个初步的认识。








    

